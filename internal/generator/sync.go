package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"syncgen/internal/config"
)

// generateSyncScript creates the streaming replication setup script
func (g *Generator) generateSyncScript(replica config.Replica, replicaDir string) error {
	script := fmt.Sprintf(`#!/bin/bash
# Streaming replication setup script for replica %s
# Generated by ha-syncgen

set -e

LOG_FILE="/var/log/ha-syncgen/setup-%s.log"
PRIMARY_HOST="%s"
PRIMARY_PORT="%d"
REPLICATION_USER="%s"
DATA_DIR="%s"
REPLICATION_SLOT="%s"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

echo "$(date): Setting up streaming replication from %s to %s" >> "$LOG_FILE"

# Stop PostgreSQL if running
systemctl stop postgresql || true

# Backup existing data directory if it exists
if [ -d "$DATA_DIR" ]; then
    echo "$(date): Backing up existing data directory" >> "$LOG_FILE"
    mv "$DATA_DIR" "${DATA_DIR}.backup.$(date +%%s)"
fi

# Create fresh data directory
mkdir -p "$DATA_DIR"
chown postgres:postgres "$DATA_DIR"

# Perform base backup from primary
echo "$(date): Starting base backup from primary" >> "$LOG_FILE"
sudo -u postgres pg_basebackup \
    -h "$PRIMARY_HOST" \
    -p "$PRIMARY_PORT" \
    -U "$REPLICATION_USER" \
    -D "$DATA_DIR" \
    -S "$REPLICATION_SLOT" \
    -v -P -W >> "$LOG_FILE" 2>&1

# Create standby.signal file to indicate this is a standby server
sudo -u postgres touch "$DATA_DIR/standby.signal"

# Create recovery configuration
cat > "$DATA_DIR/postgresql.auto.conf" << EOF
# Streaming replication configuration
primary_conninfo = 'host=%s port=%d user=%s application_name=%s'
primary_slot_name = '%s'
EOF

chown postgres:postgres "$DATA_DIR/postgresql.auto.conf"

echo "$(date): Base backup completed successfully" >> "$LOG_FILE"

# Start PostgreSQL as standby
systemctl start postgresql

echo "$(date): Streaming replication setup completed for %s" >> "$LOG_FILE"
`,
		replica.Host, replica.Host, g.config.Primary.Host, g.config.Primary.Port,
		g.config.Primary.ReplicationUser, g.config.Primary.DataDirectory,
		replica.ReplicationSlot, g.config.Primary.Host, replica.Host,
		g.config.Primary.Host, g.config.Primary.Port,
		g.config.Primary.ReplicationUser, replica.Host, replica.ReplicationSlot,
		replica.Host)

	return g.writeFile(filepath.Join(replicaDir, "setup_replication.sh"), script)
}

// writeFile writes content to a file and makes scripts executable
func (g *Generator) writeFile(path, content string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(content)
	if err != nil {
		return err
	}

	// Make scripts executable
	if filepath.Ext(path) == ".sh" {
		if err := os.Chmod(path, 0755); err != nil {
			return fmt.Errorf("failed to make script executable: %w", err)
		}
	}

	return nil
}
