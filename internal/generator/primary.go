package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

// generatePrimaryFiles creates configuration files for the primary PostgreSQL server
func (g *Generator) generatePrimaryFiles() error {
	primaryDir := filepath.Join(g.outputDir, "primary")
	if err := os.MkdirAll(primaryDir, 0755); err != nil {
		return err
	}

	// Generate PostgreSQL configuration patches
	if err := g.generatePostgreSQLConfig(primaryDir); err != nil {
		return err
	}

	// Generate pg_hba.conf patches for replication
	if err := g.generatePgHbaConfig(primaryDir); err != nil {
		return err
	}

	// Generate replication slot setup script
	if err := g.generateReplicationSlotSetup(primaryDir); err != nil {
		return err
	}

	return nil
}

// generatePostgreSQLConfig creates postgresql.conf patches for streaming replication
func (g *Generator) generatePostgreSQLConfig(primaryDir string) error {
	config := fmt.Sprintf(`# PostgreSQL Streaming Replication Configuration
# Generated by ha-syncgen
# Add these settings to your postgresql.conf

# WAL (Write-Ahead Logging) settings for replication
wal_level = %s
max_wal_senders = %d
wal_keep_size = %s

# Archive settings (optional but recommended)
archive_mode = on
archive_command = 'test ! -f /var/lib/postgresql/archive/%%f && cp %%p /var/lib/postgresql/archive/%%f'

# Hot standby settings
hot_standby = %t

# Synchronous replication settings
synchronous_commit = %s

# Enable replication slots (recommended)
max_replication_slots = %d

# Connection settings
listen_addresses = '*'
port = %d

# Logging for replication monitoring
log_replication_commands = on
log_min_messages = info
log_line_prefix = '%%t [%%p]: [%%l-1] user=%%u,db=%%d,app=%%a,client=%%h '

# Performance tuning for replication
max_connections = 100
shared_buffers = 256MB
effective_cache_size = 1GB
`,
		g.config.Options.WalLevel,
		g.config.Options.MaxWalSenders,
		g.config.Options.WalKeepSize,
		g.config.Options.HotStandby,
		g.config.Options.SynchronousCommit,
		len(g.config.Replicas)+2, // +2 for extra slots
		g.config.Primary.Port)

	return g.writeFile(filepath.Join(primaryDir, "postgresql.conf.patch"), config)
}

// generatePgHbaConfig creates pg_hba.conf entries for replication
func (g *Generator) generatePgHbaConfig(primaryDir string) error {
	hbaConfig := fmt.Sprintf(`# pg_hba.conf entries for PostgreSQL streaming replication
# Generated by ha-syncgen
# Add these lines to your pg_hba.conf file

# Replication connections from replica servers
`)

	// Add entries for each replica
	for _, replica := range g.config.Replicas {
		hbaConfig += fmt.Sprintf("host    replication    %s    %s/32    md5\n",
			g.config.Primary.ReplicationUser, replica.Host)
	}

	hbaConfig += fmt.Sprintf(`
# Allow local replication connections (for monitoring)
local   replication    %s                         md5
host    replication    %s    127.0.0.1/32     md5
host    replication    %s    ::1/128          md5

# Database connections for health checks
`, g.config.Primary.ReplicationUser, g.config.Primary.ReplicationUser, g.config.Primary.ReplicationUser)

	for _, replica := range g.config.Replicas {
		hbaConfig += fmt.Sprintf("host    postgres       %s    %s/32    md5\n",
			g.config.Primary.ReplicationUser, replica.Host)
	}

	return g.writeFile(filepath.Join(primaryDir, "pg_hba.conf.patch"), hbaConfig)
}

// generateReplicationSlotSetup creates a script to set up replication slots on the primary
func (g *Generator) generateReplicationSlotSetup(primaryDir string) error {
	script := fmt.Sprintf(`#!/bin/bash
# Replication slot setup script for PostgreSQL primary
# Generated by ha-syncgen

set -e

echo "Setting up replication slots on primary PostgreSQL server..."

# Connect to PostgreSQL and create replication slots
psql -h %s -p %d -U postgres -d postgres << 'EOF'
-- Create replication user if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = '%s') THEN
        CREATE ROLE %s WITH REPLICATION LOGIN PASSWORD '%s';
        GRANT CONNECT ON DATABASE postgres TO %s;
    END IF;
END
$$;

`, g.config.Primary.Host, g.config.Primary.Port,
		g.config.Primary.ReplicationUser, g.config.Primary.ReplicationUser,
		g.config.Primary.ReplicationPassword, g.config.Primary.ReplicationUser)

	// Add replication slot creation for each replica
	for _, replica := range g.config.Replicas {
		script += fmt.Sprintf(`-- Create replication slot for %s
SELECT CASE 
    WHEN NOT EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = '%s') 
    THEN pg_create_physical_replication_slot('%s')
    ELSE NULL
END;

`, replica.Host, replica.ReplicationSlot, replica.ReplicationSlot)
	}

	script += `EOF

echo "Replication slots setup completed!"
echo "Verifying replication slots:"
psql -h ` + g.config.Primary.Host + ` -p ` + fmt.Sprintf("%d", g.config.Primary.Port) + ` -U postgres -d postgres -c "SELECT slot_name, slot_type, active FROM pg_replication_slots;"

echo ""
echo "Next steps:"
echo "1. Ensure postgresql.conf includes the generated configuration patches"
echo "2. Ensure pg_hba.conf includes the generated authentication rules"
echo "3. Restart PostgreSQL service: sudo systemctl restart postgresql"
echo "4. Run the replica setup scripts on each replica server"
`

	return g.writeFile(filepath.Join(primaryDir, "setup_primary.sh"), script)
}
